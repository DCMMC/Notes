% !TeX encoding = UTF-8
% !TeX program = xelatex
% !TeX spellcheck = en_US

\documentclass[degree=project,degree-type=project,cjk-font=windows]{thuthesis}
\usepackage{mathtools}
\usepackage{tikz}
\newfontface\EmojiFont{Twemoji Mozilla}[Renderer=HarfBuzz]
\usetikzlibrary{shapes,arrows}
\usepackage[autosize]{dot2texi}
% Syntax Highlighting in LaTeX, need pygments
% Must build with xelatex -shell-escape -enable-8bit-chars.
\usepackage{minted}
% https://tex.stackexchange.com/a/112573
\usepackage{tcolorbox}
\usepackage{etoolbox}
\BeforeBeginEnvironment{minted}{\begin{tcolorbox}}%
\AfterEndEnvironment{minted}{\end{tcolorbox}}%
% color for minted
\definecolor{friendlybg}{HTML}{f0f0f0}


% è®ºæ–‡åŸºæœ¬é…ç½®ï¼ŒåŠ è½½å®åŒ…ç­‰å…¨å±€é…ç½®
\thusetup{
    output = electronic,
    title  = {å®éªŒäºŒ},
    author  = {è‚–æ–‡éŸ¬},
    studentid = {2020214245},
    major = {ç”µå­ä¿¡æ¯ï¼ˆè®¡ç®—æœºæŠ€æœ¯ï¼‰},
    email = {xwt20@mails.tsinghua.edu.cn},
    course = {å¯†ç å­¦ä¸ç½‘ç»œå®‰å…¨},
    include-spine = false,
}


\usepackage{float}
\usepackage[sort]{natbib}
\bibliographystyle{thuthesis-numeric}
\graphicspath{{figures/}}


\setlist[enumerate,1]{label=\arabic*.}
\setlist[enumerate,2]{label=(\alph*)}
\setlist[enumerate,3]{label=\roman*.}
\setlist[enumerate,4]{label=\greek*}

\newcommand*\justify{%
  \fontdimen2\font=0.4em% interword space
  \fontdimen3\font=0.2em% interword stretch
  \fontdimen4\font=0.1em% interword shrink
  \fontdimen7\font=0.1em% extra space
  \hyphenchar\font=`\-% allowing hyphenation
}

\renewcommand{\texttt}[1]{%
  \begingroup
  \ttfamily
  \begingroup\lccode`~=`/\lowercase{\endgroup\def~}{/\discretionary{}{}{}}%
  \begingroup\lccode`~=`[\lowercase{\endgroup\def~}{[\discretionary{}{}{}}%
  \begingroup\lccode`~=`.\lowercase{\endgroup\def~}{.\discretionary{}{}{}}%
  \catcode`/=\active\catcode`[=\active\catcode`.=\active
  \justify\scantokens{#1\noexpand}%
  \endgroup
}


\begin{document}

% å°é¢
\maketitle

\frontmatter
% \input{data/abstract}

% ç›®å½•
% \tableofcontents

% æ’å›¾å’Œé™„è¡¨æ¸…å•
% \listoffiguresandtables
% \listoffigures           % æ’å›¾æ¸…å•

% æ­£æ–‡éƒ¨åˆ†
\mainmatter

\chapter{å®éªŒä»‹ç»}
RSAåŠ å¯†ç®—æ³•æ˜¯åº”ç”¨æœ€å¹¿æ³›çš„å…¬é’¥åŠ å¯†ç®—æ³•ï¼Œæœ¬æ¬¡å®éªŒå®ç°åŸºäºRSAç®—æ³•çš„åŠ è§£å¯†ä»¥åŠæ•°å­—ç­¾ååŠŸèƒ½ï¼ŒåŒ…å«ä»¥ä¸‹4ç§æ“ä½œï¼šç”Ÿæˆå¯†é’¥å¯¹ã€å…¬é’¥åŠ å¯†ã€ç§é’¥è§£å¯†å’Œæ•°å­—ç­¾åã€‚
æœ¬æ¬¡å®éªŒä¸­å¯†é’¥é•¿åº¦ä¸º2048æ¯”ç‰¹ã€‚
å®éªŒä½¿ç”¨ Rust è¯­è¨€å®ç° RSA-2048 çš„å¯†é’¥ç”Ÿæˆï¼ŒåŠ å¯†è§£å¯†ï¼Œä»¥åŠæ•°å­—ç­¾åæ“ä½œã€‚

å®éªŒç›®çš„ï¼š

\begin{enumerate}
    \item ç†Ÿæ‚‰ RSA å…¬é’¥åŠ å¯†ç®—æ³•çš„æ€è·¯
    \item å­¦ä¹  RSA å®ç°ä¸Šçš„æŠ€å·§
    \item å­¦ä¹  rust è¯­è¨€çš„åŸºæœ¬ç”¨æ³•
\end{enumerate}

å®éªŒå¹³å°ï¼š

\begin{enumerate}
    \item rust è¯­è¨€
\end{enumerate}

\chapter{å®éªŒå†…å®¹}

\section{ç”Ÿæˆå¯†é’¥å¯¹}

å¯†é’¥å¯¹çš„ç”Ÿæˆè¿‡ç¨‹åŒ…æ‹¬é€‰å–éšæœºæ•°ï¼Œå¯¹éšæœºæ•°è¿›è¡Œç´ æ€§æµ‹è¯•ï¼Œæ ¹æ®ç´ æ•°på’Œqè®¡ç®—nï¼Œéšæœºé€‰æ‹©å’Œnçš„æ¬§æ‹‰å‡½æ•°äº’è´¨çš„eï¼Œè®¡ç®—eçš„é€†å…ƒdã€‚
é€‰å–çš„å¤§ç´ æ•°på’Œqåº”å½“æ»¡è¶³ç°æœ‰çš„å®‰å…¨æ€§è¦æ±‚ï¼Œä¸”è‡³å°‘ä½¿ç”¨ä¸¤ç§ä¸åŒçš„ç®—æ³•è¿›è¡Œç´ æ€§æµ‹è¯•ï¼Œè¯·åœ¨å®éªŒæŠ¥å‘Šä¸­è¯´æ˜ä½ é€‰æ‹©å‚æ•°å’Œç®—æ³•çš„å®‰å…¨æ€§ä»¥åŠæ•ˆç‡ã€‚
é€‰å–çš„eåŒæ ·åº”å½“æ»¡è¶³å®‰å…¨æ€§è¦æ±‚ï¼Œè‡³å°‘ä½¿ç”¨ä¸¤ç§ä¸åŒçš„ç®—æ³•è¿›è¡Œè®¡ç®—é€†å…ƒdã€‚

\subsection{ç´ æ€§æµ‹è¯•}

æœ¬å®ç°é‡‡ç”¨äº†ä¸¤ç§æœ€ä¸»æµçš„æ¦‚ç‡ç´ æ€§æµ‹è¯•ç®—æ³•ï¼š

\begin{enumerate}
  \item \textbf{Miller-Rabin æµ‹è¯•},ä½œä¸ºè´¹é©¬å®šç†çš„æ‰©å±•ï¼Œæ¯ä¸€è½® MR æµ‹è¯•çš„ä¼ªç´ æ•°çš„å¯èƒ½æ€§ä¸º $\frac{1}{4}$ï¼Œæ‰€ä»¥ $k$ è½®é€šè¿‡ä»ç„¶æ˜¯ä¼ªç´ æ•°çš„å¯èƒ½æ€§ä¸º $4^{-k}$ã€‚å¤æ‚åº¦ $O(k \log^2 n)$ ($k$ ä¸ºæµ‹è¯•è½®æ•°)ã€‚
  \item \textbf{Baillieâ€“PSW æµ‹è¯•}, ç»“åˆäº† Miller-Rabin æµ‹è¯•å’Œå¼º Lucas æ¦‚ç‡æµ‹è¯•ã€‚å¤æ‚åº¦ä¸º $O(log^2 n)$ï¼Œä½äº MR æµ‹è¯•ã€‚
\end{enumerate}

å€¼å¾—ä¸€æçš„æ˜¯ï¼Œç´ æ€§æµ‹è¯•çš„ä¸€äº›ä¼˜åŒ–æŠ€å·§ï¼š

\begin{enumerate}
  \item é¦–å…ˆæµ‹è¯•æ˜¯å¦æ˜¯å¸¸ç”¨çš„å°ç´ æ•°çš„å€æ•°ï¼Œå…·ä½“æ¥è¯´ï¼ŒRSA-2048 ä¼šé¦–å…ˆåˆ¤æ–­éšæœºæ•°æ˜¯å¦æ˜¯è‡ªç„¶æ•°ä¸­å‰ 384 ä¸ªç´ æ•°çš„å€æ•°ã€‚è¯¥æŠ€å·§å’Œ 384 çš„æ¥æºå‚è€ƒçš„æ˜¯ OpenSSL æœ€æ–°ä»£ç çš„ \texttt{bn\_prime.c\#L74:12}ã€‚
  \item å¦‚æœå½“ç„¶éšæœºæ•°ä¸æ˜¯ç´ æ•°ï¼Œä¼šå¯¹éšæœºæ•° +2 å†åˆ¤æ–­æ˜¯å¦æ˜¯ç´ æ•°ï¼Œå› ä¸ºæŒ‰ç…§ç´ æ•°å®šç†ï¼Œå¯¹äº RSA-2048ï¼Œè¿ç»­çš„æ•°ä¸­å‡ºç°ç´ æ•°çš„æ¦‚ç‡ä¸º $\frac{1}{\log(2^{2048})} \approx \frac{1}{1418}$ã€‚æœ€åæƒ…å†µä¸‹å°è¯• 700 å¤šæ¬¡å°±ä¸€å®šä¼šé‡åˆ°ç´ æ•°ã€‚
\end{enumerate}

miller rabin æµ‹è¯•çš„ä»£ç ï¼š

\begin{minted}[texcomments,tabsize=2,fontsize=\footnotesize,style=friendly,bgcolor=friendlybg]{rust}
fn miller_rabin_test(rnd: &Integer, iteration: u8, base_2: bool) {
    let n = Integer::from(rnd);
    let mut d: Integer = Integer::from(&n - 1);
    let mut r = 0;
    while !(&d.get_bit(0)) { d >>= 1; r += 1; }
    let mut rng = RandState::new();
    'witness_loop: for _ in 0..iteration {
        let mut n_sub = Integer::from(&n - 2u8);
        let a = if base_2 {
            Integer::from(2)
        } else {
            Integer::from(n_sub.random_below_ref(&mut rng)) + 2u8
        };
        let mut x = a.pow_mod(&d, &n).unwrap();
        n_sub += 1u8;
        if &x == &1 || &x == &n_sub {
            continue 'witness_loop;
        }
        for _ in 1..r {
            x = x.pow_mod(&Integer::from(2), &n).unwrap();
            if &x == &n_sub {
                continue 'witness_loop;
            }
        }
        return false;
    }
    true
}
\end{minted}

å› ä¸ºå›¿äºç¯‡å¹…ï¼Œå…·ä½“çš„ä»£ç æ³¨é‡Šå‚è§æºç ã€‚

\subsection{æ¨¡é€†è¿ç®—}

æœ¬å®ç°ä¸­ç´ æ•° p å’Œ q å‡ä¸º 2048 ä½ï¼Œæ˜¯ç›®å‰ä¸»æµçš„ RSA-2048 å®ç°ï¼Œå¯†é’¥é•¿åº¦ç¬¦åˆå®‰å…¨è¦æ±‚ã€‚

å¯¹äº e çš„é€‰æ‹©ï¼Œè¿‡å°çš„ eï¼ˆä¾‹å¦‚ 3ï¼‰ä¼šå­˜åœ¨å®‰å…¨é—®é¢˜ï¼ŒåŒæ—¶çŸ­æ¯”ç‰¹é•¿åº¦å’Œå°çš„ Hamming æƒé‡èƒ½å¤Ÿä½¿å¾—åŠ å¯†çš„æ•ˆç‡æ›´åŠ é«˜ï¼Œç›®å‰ OpenSSL ä»¥åŠå…¶ä»–å®ç°å¹¿æ³›é‡‡ç”¨çš„æ˜¯ 65537 (0x10001).
æœ¬å®ç°å‚è€ƒä¸»æµå®ç°ï¼Œe çš„é€‰æ‹©ä¹Ÿæ˜¯ 65537.

d ä½œä¸º e çš„æ¨¡ $\phi(n)$ é€†å…ƒï¼Œå› ä¸º n ä¸º 4096 ä½ï¼Œæ‰€ä»¥ d çš„å¼ºåº¦ä¹Ÿèƒ½å¤Ÿå¾—åˆ°ä¿è¯ã€‚

æœ¬å®ç°å…±æœ‰ä¸¤ç§æ¨¡é€†çš„ç®—æ³•å®ç°ï¼š

\begin{enumerate}
  \item \textbf{æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•}ï¼Œç®—æ³•æ•ˆç‡ $O(2 \log_{10}(\phi(n)))$ï¼ˆé™¤æ³•è¿ç®—ï¼‰ã€‚gcd çš„è®¡ç®—å¤æ‚åº¦æ¨å¯¼å¾ˆå¤æ‚ï¼Œå…·ä½“å¯ä»¥å‚è€ƒ TAOCPã€‚
  \item \textbf{å¹³æ–¹å¹‚ç®—æ³•ï¼ˆbinary exponentiationï¼‰}ï¼Œç®—æ³•æ•ˆç‡ $O(\log(\phi(n)))$ã€‚ä½†æ˜¯è¯¥ç®—æ³•åªé€‚ç”¨äº $\phi(n)$ ä¸ºç´ æ•°çš„æƒ…å†µã€‚
\end{enumerate}

ä¸¤ç§æ¨¡é€†çš„ç®—æ³•å®ç°ä»£ç ï¼š

  \begin{minted}[texcomments,tabsize=2,fontsize=\footnotesize,style=friendly,bgcolor=friendlybg]{rust}
fn modular_inverse(e: &Integer, phi_n: &Integer, method: &str) {
    if method == "extend_gcd" {
        let mut t = Integer::from(0);
        let mut newt = Integer::from(1);
        let mut r = Integer::from(phi_n);
        let mut newr = Integer::from(e);
        let mut quotient = Integer::new();
        let mut tmp = Integer::new();
        while newr.significant_bits() != 0 {
            quotient.assign(&r / &newr);
            tmp.assign(&quotient * &newt);
            tmp *= -1; tmp += &t; t.assign(&newt);
            newt.assign(&tmp);
            tmp.assign(&quotient * &newr);
            tmp *= -1; tmp += &r; r.assign(&newr);
            newr.assign(&tmp);
        }
        if r > 1 { panic!("e is not invertible!"); }
        if t < 0 { t += phi_n; }
        return t;
    } else if method == "binary_exp" {
        if baillie_psw(phi_n, true) {
            println!("phi_n is prime, use binary_exp");
            return Integer::from((&e).pow_mod_ref(
                    &Integer::from(phi_n - 2), &phi_n).unwrap())
        } else {
            return Integer::from((&e).invert_ref(&phi_n).unwrap());
        }
    }
}
  \end{minted}

\subsection{å¯†é’¥ç”Ÿæˆ}

å¯†é’¥ç”Ÿæˆå°±æ˜¯é€šè¿‡ä¸¤ä¸ªå¤§éšæœºç´ æ•° $p,q$ ç›¸ä¹˜è®¡ç®—å‡º $n$ï¼Œç„¶åå†è®¡ç®— $\phi(n) = (p-1)(q-1)$ï¼Œç„¶åé€šè¿‡ $e = 65537$ è®¡ç®—å®ƒçš„æ¨¡é€† $de = 1 (\text{mod } \phi(n))$ã€‚
ä»£ç å¦‚ä¸‹ï¼š

  \begin{minted}[texcomments,tabsize=2,fontsize=\footnotesize,style=friendly,bgcolor=friendlybg]{rust}
fn rsa_key_phase1() -> (Integer, Integer, Integer) {
    let p = generate_prime("miller_rabin");
    let q = generate_prime("miller_rabin");
    let n = Integer::from(&p * &q);
    let phi_n = (p - 1) * (q - 1);
    let e = Integer::from(65537);
    (n, phi_n, e)
}

fn rsa_key_pair(method: &str) -> (Integer, Integer, Integer) {
    let (n, phi_n, e) = rsa_key_phase1();
    let d = modular_inverse(&e, &phi_n, method);
    (n, e, d)
}
\end{minted}

\subsection{è¿è¡Œç»“æœ}

\begin{figure}[h]
\centering%
\includegraphics[width=\linewidth]{rsa_t1.png}
  \caption{å¯†é’¥ç”Ÿæˆè¿è¡Œç»“æœ}
  \label{fig:t1}
\end{figure}

RSA çš„å®ç°è·Ÿä¹‹å‰ AES çš„å®ç°éƒ½ä½¿ç”¨ cargo ç»„ç»‡é¡¹ç›®ä»£ç ã€‚
ç¼–è¯‘è¿è¡Œçš„ä»£ç ï¼š

  \begin{minted}[texcomments,tabsize=2,fontsize=\footnotesize,style=friendly,bgcolor=friendlybg]{bash}
  cd target/release && cargo build --release && ./crypto
  \end{minted}

å¯†é’¥ç”Ÿæˆçš„ $n, e, d$ å¦‚å›¾~\ref{fig:t1} æ‰€ç¤ºï¼Œå…¶ä¸­ $n$ æ˜¯ä¸¤ä¸ª 2048 ä½éšæœºå¤§ç´ æ•° $p, q$ çš„ä¹˜ç§¯, $e$ åˆ™æ˜¯å›ºå®šçš„ã€‚

\section{å…¬é’¥åŠ å¯†}

æœ¬é¢˜ä½¿ç”¨å…¬é’¥å¯¹æ˜æ–‡è¿›è¡ŒåŠ å¯†ï¼Œæ˜æ–‡ä¸º 'Cryptography and Network Security;å­¦å·;å§“åæ‹¼éŸ³' ï¼Œä½¿ç”¨è‡ªå·±çš„å­¦å·å’Œå§“åæ‹¼éŸ³æ›¿ä»£å¯¹åº”ä½ç½®å­—ç¬¦ä¸²ã€‚åŠ å¯†è¿‡ç¨‹åŒ…æ‹¬åˆ†å—ï¼Œå­—ç¬¦ä¸²è½¬æ•°å­—ï¼Œå…¬é’¥åŠ å¯†ã€‚åˆ†å—å°†å¾…åŠ å¯†çš„å­—ç¬¦ä¸²åˆ†è§£æˆå¤šä¸ªå—ï¼Œå¯¹äºæ¯ä¸ªå—åˆ†åˆ«åŠ å¯†ã€‚æ¯ä¸ªå—çš„é•¿åº¦å–å†³äºé€‰æ‹©çš„å¤§ç´ æ•°på’Œqçš„å¤§å°ï¼Œå…·ä½“æ¥è¯´ï¼Œæ¯”ç‰¹ä¸²çš„é•¿åº¦åº”å½“å°äºlog2nã€‚å—é•¿åº¦ä¸è¶³çš„éƒ¨åˆ†éœ€è¦ä½¿ç”¨å¡«å……å­—ç¬¦è¡¥é½ã€‚å­—ç¬¦ä¸²è½¬æ•°å­—å¯ä»¥å…ˆè½¬åŒ–æˆæ¯”ç‰¹ä¸²ï¼Œå†è½¬åŒ–ä¸ºæ•°å­—ï¼Œæˆ–è€…é‡‡ç”¨è‡ªè¡Œè§„å®šçš„è½¬åŒ–è§„åˆ™ã€‚å…¬é’¥åŠ å¯†éƒ¨åˆ†è¯·ä½¿ç”¨å¿«é€Ÿå¹‚ç®—æ³•è®¡ç®—å¯†æ–‡ã€‚è¾“å‡ºæ¯ä¸€æ­¥çš„ç»“æœã€‚

\subsection{å¿«é€Ÿå¹‚ç®—æ³•}
å¿«é€Ÿå¹‚ç®—æ³•å°±æ˜¯å¯¹è®¡ç®— $m^e$ çš„ä¼˜åŒ–ï¼Œå°±æ˜¯æŠŠ $e$ ä»¥äºŒè¿›åˆ¶è¡¨ç¤ºï¼Œå¤æ‚åº¦ $O(2\log(n))$.
å®ç°ä»£ç å¦‚ä¸‹ï¼š

  \begin{minted}[texcomments,tabsize=2,fontsize=\footnotesize,style=friendly,bgcolor=friendlybg]{rust}
fn quick_pow_mod(mut m: Integer, e: &Integer, n: &Integer) -> Integer {
  m %= n;
  let mut ans = Integer::from(1);
  let mut e_curr = Integer::from(e);
  let two = Integer::from(2);
  while e_curr.significant_bits() != 0 {
      if e_curr.get_bit(0) {
          ans *= &m; ans %= n;
      }
      m.pow_mod_mut(&two, n).unwrap();
      e_curr >>= 1;
  }
  ans
}
  \end{minted}

\subsection{åŠ å¯†å¡«å……å­—ç¬¦}

é¦–å…ˆè®¡ç®— $\log_2 n$ ä½œä¸ºåŠ å¯†å—çš„å¤§å°ï¼Œå› ä¸º $n$ ä¸º 4096 ä½ï¼Œä¹Ÿå°±æ˜¯æ¯ä¸€å—ä¸º 512 å­—èŠ‚ã€‚
å¯¹äºæ˜æ–‡çš„æœ€åä¸€å—ä¸è¶³ 512 å­—èŠ‚çš„è¯ï¼Œåœ¨æœ€åé¢å¡«å…… 0.
å¯¹äºæ¯ä¸€å—çš„åŠ å¯†ï¼Œå°±æ˜¯æŠŠè¿™ä¸€å—å½“åšä¸€ä¸ªå¤§æ•´æ•° $m$, ç„¶åè®¡ç®— $m^e \text{ mod } n$.
å…¶ä¸­ $e, n$ ä¸ºå…¬é’¥å¯¹ã€‚
ä»£ç å¦‚ä¸‹ï¼š

  \begin{minted}[texcomments,tabsize=2,fontsize=\footnotesize,style=friendly,bgcolor=friendlybg]{rust}
fn rsa_encrypt(key: (&Integer, &Integer), plaintext: &str) -> Vec<u8> {
    let (n, e)  = key;
    let block_size = (n.significant_bits() as f64 / 8.0).ceil() as usize;
    let mut padded_bytes: Vec<u8> = plaintext.to_string().into_bytes();
    let mut pad_size = padded_bytes.len() % block_size;
    if pad_size != 0 {
        pad_size = block_size - pad_size;
    }
    println!("padding_size={}", pad_size);
    padded_bytes.extend(vec![PAD_BYTE; pad_size]);
    for block in padded_bytes.chunks_mut(block_size) {
        let mut num_str = block.iter()
            .map(|x| format!("{:02X}", x))
            .fold(String::from(""),
                  |res: String, curr: String| res + &curr
            );
        let mut m = Integer::from(Integer::parse_radix(
            num_str, 16).unwrap());
        m = quick_pow_mod(m, e, n);
        let mut digits = m.to_string_radix(16);
        if digits.len() % 2 == 1 { digits.insert(0, '0'); }
        for idx in 0..block.len() {
            block[idx] = u8::from_str_radix(&digits[
              (idx*2)..(idx*2+2)], 16).unwrap();
        }
    }
    padded_bytes
}
\end{minted}

\subsection{è¿è¡Œç»“æœ}

\begin{figure}[h]
\centering%
\includegraphics[width=\linewidth]{rsa_t2.png}
  \caption{å…¬é’¥åŠ å¯†è¿è¡Œç»“æœ}
  \label{fig:t2}
\end{figure}

è¿è¡Œç»“æœå¦‚å›¾~\ref{fig:t2}æ‰€ç¤ºï¼Œæ˜æ–‡ä¸ºâ€œCryptography and Network Security; 2020214245; è‚–æ–‡éŸ¬ (Wentao Xiao) ğŸ‰ğŸš€â€ï¼ŒåŠ å¯†ç»“æœä¸ºä¸€ä¸ªåŠ å¯†å—ã€‚
å€¼å¾—ä¸€æçš„æ˜¯ï¼Œè™½ç„¶æ˜æ–‡å¯¹åº”çš„å—å¤§éƒ¨åˆ†å†…å®¹éƒ½æ˜¯å¡«å……å­—ç¬¦ï¼Œä½†æ˜¯åŠ å¯†å—å°±æ˜¯å…¨æ»¡ï¼ˆæ²¡æœ‰å¡«å……å­—ç¬¦ï¼‰çš„æ•°æ®ã€‚

\section{ç§é’¥è§£å¯†}

ç§é’¥è§£å¯†æ˜¯å…¬é’¥åŠ å¯†æ“ä½œçš„é€†æ“ä½œï¼Œé¦–å…ˆéœ€è¦å°†æ¯”ç‰¹ä¸²è½¬åŒ–ä¸ºæ•°å­—ï¼Œç„¶åå¯¹æ•°å­—ä½¿ç”¨ç§é’¥dè¿›è¡Œè§£å¯†ï¼ŒåŒæ ·å»ºè®®ä½¿ç”¨å¿«é€Ÿå¹‚ç­‰ç®—æ³•è®¡ç®—ï¼Œç„¶åå°†æ•°å­—è¿˜åŸæˆå­—ç¬¦ä¸²ï¼Œè¾“å‡ºæ¯ä¸€æ­¥çš„ç»“æœã€‚

\subsection{ä»£ç è¯´æ˜}

å› ä¸º RSA åŠ å¯†è§£å¯†å·®ä¸å¤šä¸€æ¨¡ä¸€æ ·ï¼Œè€Œä¸”éƒ½èƒ½ç®€å•ã€‚
è§£å¯†è¿‡ç¨‹å°±æ˜¯å°±æ˜¯è®¡ç®— $c^d \text{ mod } n$ï¼Œå…¶ä¸­ $c, d, n$ åˆ†åˆ«ä¸ºå¯†æ–‡ï¼ˆå—ï¼‰ï¼Œç§é’¥å¯¹ã€‚
å»é™¤å¡«å……å­—ç¬¦çš„è¿‡ç¨‹ä¹Ÿæ¯”è¾ƒç®€å•ï¼Œå› ä¸ºå¡«å……çš„å­—ç¬¦å°±æ˜¯ 0ï¼Œæ‰€ä»¥åªéœ€è¦æŠŠæœ€åä¸€å—æœ€åé¢è¿ç»­çš„ 0 å»æ‰å°±å¥½å•¦ã€‚

å®Œæ•´çš„ä»£ç å¦‚ä¸‹ï¼š

  \begin{minted}[texcomments,tabsize=2,fontsize=\footnotesize,style=friendly,bgcolor=friendlybg]{rust}
fn rsa_decrypt(key: (&Integer, &Integer), cipher: &Vec<u8>) -> String {
    title("decryption");
    let (n, d) = key;
    let block_size = (n.significant_bits() as f64 / 8.0).ceil() as usize;
    let chunks = cipher.chunks(block_size);
    let num_chunks = chunks.len();
    let mut plain = String::new();
    for (idx, block) in chunks.enumerate() {
        let mut num_str = block.iter()
            .map(|x| format!("{:02X}", x))
            .fold(String::from(""),
                  |res: String, curr: String| res + &curr);
        if num_str.as_bytes()[0] == '0' as u8 {
            num_str.remove(0); }
        let mut c = Integer::from(Integer::parse_radix(
            num_str, 16).unwrap());
        println!("c={}", c);
        c = quick_pow_mod(c, d, n);
        let mut digits = c.to_string_radix(16);
        if digits.len() % 2 == 1 {
            digits.insert(0, '0'); }
        let mut c_block = vec![0u8; digits.len() / 2];
        for idx in 0..(digits.len() / 2) {
            c_block[idx] = u8::from_str_radix(&digits[(idx*2)..(idx*2+2)],
              16).unwrap(); }
        if idx == (num_chunks - 1) {
            while c_block[c_block.len() - 1] == PAD_BYTE {
                c_block.pop(); } }
        plain.push_str(&String::from_utf8(c_block).unwrap());
    }
    plain
}
\end{minted}

\subsection{è¿è¡Œç»“æœ}

\begin{figure}[h]
\centering%
\includegraphics[width=\linewidth]{rsa_t3.png}
  \caption{ç§é’¥è§£å¯†è¿è¡Œç»“æœ}
  \label{fig:t3}
\end{figure}

è¿è¡Œç»“æœå¦‚å›¾~\ref{fig:t3}æ‰€ç¤ºï¼Œè§£å¯†å‡ºæ¥çš„æ˜æ–‡ä¸ºâ€œCryptography and Network Security; 2020214245; è‚–æ–‡éŸ¬ (Wentao Xiao)â€ã€‚
è§£å¯†å‡ºæ¥çš„å—å½“ä¸­å¤§éƒ¨åˆ†ä¸ºå¡«å……å­—ç¬¦ã€‚

\section{æ•°å­—ç­¾å}

ç­¾åçš„å†…å®¹å¯ä»¥å’Œé¢˜ç›®2ä¸­ä½¿ç”¨çš„å­—ç¬¦ä¸²ç›¸åŒï¼Œä¹Ÿå¯ä»¥æ˜¯ä»æ–‡ä»¶ä¸­å¯¼å…¥çš„ä»»æ„ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚

ç­¾åè¿‡ç¨‹ä¸»è¦åŒ…æ‹¬æ¶ˆæ¯æ•£åˆ—ï¼Œç§é’¥åŠ å¯†ï¼ŒéªŒè¯è¿‡ç¨‹åŒ…æ‹¬å…¬é’¥è§£å¯†ï¼Œå¯¹æ¯”éªŒè¯ã€‚é¦–å…ˆéœ€è¦å°†å­—ç¬¦ä¸²å‹ç¼©æˆå“ˆå¸Œå€¼ï¼Œåœ¨è¿™ä¸€ç¯èŠ‚ä¸­å…è®¸ä½¿ç”¨ç°æœ‰çš„å“ˆå¸Œå‡½æ•°åº“ï¼ŒPythonä¸­çš„å“ˆå¸Œå‡½æ•°åº“ä¸ºhashlibã€‚ç§é’¥åŠ å¯†å’Œå…¬é’¥è§£å¯†çš„è¿‡ç¨‹åŒé¢˜ç›®2å’Œ3ï¼Œä½¿ç”¨é¢˜ç›®1ä¸­ç”Ÿæˆçš„å¯†é’¥å¯¹ï¼Œæ³¨æ„è¦ä½¿ç”¨ç§é’¥åŠ å¯†ï¼Œå…¬é’¥è§£å¯†ï¼Œä¸é¢˜ç›®2å’Œ3ä¸­æ˜¯ç›¸åçš„ï¼Œè¾“å‡ºæ¯ä¸€æ­¥çš„ç»“æœã€‚

\subsection{ä»£ç è¯´æ˜}

å€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒRSAåœ¨ä¼ è¾“åŠ å¯†çš„æ•°æ®çš„æ—¶å€™ï¼Œå‘é€è€…è¦ç”¨æ¥å—è€…çš„å…¬é’¥åŠ å¯†æ¶ˆæ¯ï¼Œç„¶åç”¨å‘é€è€…è‡ªå·±çš„ç§é’¥ç­¾åï¼ˆåŠ å¯†ï¼‰æ˜æ–‡æ¶ˆæ¯ä¸å¯†æ–‡ä¸€èµ·å‘é€ç»™æ¥å—è€…ã€‚
å› ä¸ºæ•°å­—ç­¾åå°±æ˜¯åŠ å¯†ï¼Œåªä¸è¿‡ç”¨çš„ç§˜é’¥ä¸ä¸€æ ·ï¼Œæ‰€ä»¥ä»£ç å®ç°è¿˜æ˜¯å¾ˆç®€å•çš„ã€‚
ä»£ç å¦‚ä¸‹ï¼š

  \begin{minted}[texcomments,tabsize=2,fontsize=\footnotesize,style=friendly,bgcolor=friendlybg]{rust}
fn rsa_sign(plaintext: &str) -> (Integer, Integer, Vec<u8>, String) {
    let (n, e, d) = rsa_key_pair("extend_gcd")
    let cipher = rsa_encrypt((&n, &d), plaintext);
    let mut hasher = DefaultHasher::new();
    plaintext.hash(&mut hasher);
    let hash: u64 = hasher.finish();
    let sign = quick_pow_mod(Integer::from(hash), &d, &n)
      .to_string_radix(16);
    (n, e, cipher, sign)
}

fn rsa_check_sign(cipher: &Vec<u8>, n: &Integer, e: &Integer,
                  sign: &str, plain: &str) -> bool {
    let decrypted = rsa_decrypt((n, e), cipher);
    let mut hasher = DefaultHasher::new();
    decrypted.hash(&mut hasher);
    let hash: u64 = hasher.finish();
    let hash_in_sign: u64 = quick_pow_mod(
        Integer::from(Integer::parse_radix(sign, 16).unwrap()),
        e, n).to_u64().unwrap();
    hash == hash_in_sign
}
\end{minted}

\subsection{è¿è¡Œç»“æœ}

\begin{figure}[h]
\centering%
\includegraphics[width=\linewidth]{rsa_t4.png}
  \caption{æ•°å­—ç­¾åè¿è¡Œç»“æœ}
  \label{fig:t4}
\end{figure}

å¯¹æ¶ˆæ¯â€œCryptography and Network Security; 2020214245; è‚–æ–‡éŸ¬ (Wentao Xiao)â€çš„RSAæ•°å­—ç­¾åï¼Œè¿è¡Œç»“æœå¦‚å›¾~\ref{fig:t4}æ‰€ç¤ºã€‚


% å…¶ä»–éƒ¨åˆ†
\backmatter

% å‚è€ƒæ–‡çŒ®
% \bibliography{ref/refs}  % å‚è€ƒæ–‡çŒ®ä½¿ç”¨ BibTeX ç¼–è¯‘

\end{document}
